import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

// Define route protection patterns
const protectedRoutes = [
  '/dashboard',
  '/admin',
  '/profile',
  '/tests',
  '/analytics',
  '/exam',
  '/practices',
  '/results'
];

const adminRoutes = [
  '/admin',
];

const publicRoutes = [
  '/auth/login',
  '/auth/register',
  '/auth/forgot-password',
  '/auth/reset-password',
  '/auth/verify-email',
  '/',
  '/about',
  '/contact',
  '/api/health'
];

// Security configuration
const SECURITY_CONFIG = {
  // Rate limiting configuration
  RATE_LIMIT: {
    AUTH_ATTEMPTS: 5, // per 15 minutes
    API_REQUESTS: 100, // per minute
    WINDOW_MS: 15 * 60 * 1000, // 15 minutes
  },
  
  // CSP sources
  CSP_SOURCES: {
    DEFAULT_SRC: ["'self'"],
    SCRIPT_SRC: [
      "'self'",
      "'unsafe-inline'", // Required for Next.js
      "'unsafe-eval'", // Required for development
      "https://apis.google.com",
      "https://www.googletagmanager.com"
    ],
    STYLE_SRC: [
      "'self'",
      "'unsafe-inline'", // Required for styled-components and CSS-in-JS
      "https://fonts.googleapis.com"
    ],
    IMG_SRC: [
      "'self'",
      "data:",
      "blob:",
      "https:",
      "https://images.unsplash.com",
      "https://res.cloudinary.com" // For uploaded images
    ],
    FONT_SRC: [
      "'self'",
      "https://fonts.gstatic.com"
    ],
    CONNECT_SRC: [
      "'self'",
      process.env.NEXT_PUBLIC_API_URL || "http://3.7.73.172",
      "https://api.github.com", // For version checks
      "wss:" // For WebSocket connections
    ],
    FRAME_SRC: ["'none'"],
    OBJECT_SRC: ["'none'"],
    BASE_URI: ["'self'"],
    FORM_ACTION: ["'self'"],
    FRAME_ANCESTORS: ["'none'"],
    MANIFEST_SRC: ["'self'"]
  }
};

// Rate limiting store (in production, use Redis or similar)
const rateLimitStore = new Map<string, { count: number; resetTime: number }>();

// Helper functions
function isProtectedRoute(pathname: string): boolean {
  return protectedRoutes.some(route => pathname.startsWith(route));
}

function isAdminRoute(pathname: string): boolean {
  return adminRoutes.some(route => pathname.startsWith(route));
}

function isPublicRoute(pathname: string): boolean {
  return publicRoutes.some(route => 
    pathname === route || 
    (route !== '/' && pathname.startsWith(route))
  );
}

function parseJWT(token: string) {
  try {
    const base64Url = token.split('.')[1];
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    const jsonPayload = decodeURIComponent(
      atob(base64)
        .split('')
        .map((c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
        .join('')
    );
    return JSON.parse(jsonPayload);
  } catch (error) {
    return null;
  }
}

function isTokenExpired(token: string): boolean {
  const payload = parseJWT(token);
  if (!payload?.exp) return true;
  return Date.now() >= (payload.exp * 1000) - 30000;
}

// Rate limiting implementation
function checkRateLimit(identifier: string, limit: number, windowMs: number): boolean {
  const now = Date.now();
  const entry = rateLimitStore.get(identifier);
  
  if (!entry || now > entry.resetTime) {
    rateLimitStore.set(identifier, { count: 1, resetTime: now + windowMs });
    return true;
  }
  
  if (entry.count >= limit) {
    return false;
  }
  
  entry.count++;
  return true;
}

// Generate Content Security Policy
function generateCSP(): string {
  const { CSP_SOURCES } = SECURITY_CONFIG;
  
  const directives = [
    `default-src ${CSP_SOURCES.DEFAULT_SRC.join(' ')}`,
    `script-src ${CSP_SOURCES.SCRIPT_SRC.join(' ')}`,
    `style-src ${CSP_SOURCES.STYLE_SRC.join(' ')}`,
    `img-src ${CSP_SOURCES.IMG_SRC.join(' ')}`,
    `font-src ${CSP_SOURCES.FONT_SRC.join(' ')}`,
    `connect-src ${CSP_SOURCES.CONNECT_SRC.join(' ')}`,
    `frame-src ${CSP_SOURCES.FRAME_SRC.join(' ')}`,
    `object-src ${CSP_SOURCES.OBJECT_SRC.join(' ')}`,
    `base-uri ${CSP_SOURCES.BASE_URI.join(' ')}`,
    `form-action ${CSP_SOURCES.FORM_ACTION.join(' ')}`,
    `frame-ancestors ${CSP_SOURCES.FRAME_ANCESTORS.join(' ')}`,
    `manifest-src ${CSP_SOURCES.MANIFEST_SRC.join(' ')}`,
    `upgrade-insecure-requests`
  ];
  
  return directives.join('; ');
}

// Security headers configuration
function getSecurityHeaders(): Record<string, string> {
  return {
    // Content Security Policy
    'Content-Security-Policy': generateCSP(),
    
    // XSS Protection
    'X-XSS-Protection': '1; mode=block',
    
    // Content Type Options
    'X-Content-Type-Options': 'nosniff',
    
    // Frame Options
    'X-Frame-Options': 'DENY',
    
    // Referrer Policy
    'Referrer-Policy': 'strict-origin-when-cross-origin',
    
    // Permissions Policy
    'Permissions-Policy': [
      'camera=()',
      'microphone=()',
      'geolocation=()',
      'payment=()',
      'usb=()',
      'screen-wake-lock=()',
      'web-share=()'
    ].join(', '),
    
    // HSTS (HTTP Strict Transport Security)
    'Strict-Transport-Security': 'max-age=63072000; includeSubDomains; preload',
    
    // Cross-Origin policies
    'Cross-Origin-Opener-Policy': 'same-origin',
    'Cross-Origin-Embedder-Policy': 'credentialless',
    'Cross-Origin-Resource-Policy': 'same-site',
    
    // Cache control for security-sensitive pages
    'Cache-Control': 'no-cache, no-store, must-revalidate',
    'Pragma': 'no-cache',
    'Expires': '0'
  };
}

// Performance headers
function getPerformanceHeaders(): Record<string, string> {
  return {
    // Server timing for performance monitoring
    'Server-Timing': 'auth;dur=0,cache;dur=0',
    
    // Early hints for preloading
    'Link': [
      '</fonts/inter.woff2>; rel=preload; as=font; type=font/woff2; crossorigin',
      '</api/v1/health>; rel=preconnect'
    ].join(', ')
  };
}

export function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  const startTime = Date.now();
  
  // Skip middleware for static files and API routes (except protected ones)
  if (
    pathname.startsWith('/_next/') ||
    pathname.startsWith('/static/') ||
    pathname.includes('.') ||
    (pathname.startsWith('/api/') && !pathname.startsWith('/api/protected'))
  ) {
    return NextResponse.next();
  }
  
  // Get client IP for rate limiting
  const clientIP = request.ip || 
    request.headers.get('x-forwarded-for')?.split(',')[0] || 
    request.headers.get('x-real-ip') || 
    'unknown';
  
  // Rate limiting for authentication routes
  if (pathname.startsWith('/auth/') && request.method === 'POST') {
    if (!checkRateLimit(`auth:${clientIP}`, SECURITY_CONFIG.RATE_LIMIT.AUTH_ATTEMPTS, SECURITY_CONFIG.RATE_LIMIT.WINDOW_MS)) {
      return new NextResponse('Too Many Requests', { 
        status: 429,
        headers: {
          'Retry-After': '900', // 15 minutes
          ...getSecurityHeaders()
        }
      });
    }
  }
  
  // General API rate limiting
  if (pathname.startsWith('/api/')) {
    if (!checkRateLimit(`api:${clientIP}`, SECURITY_CONFIG.RATE_LIMIT.API_REQUESTS, 60000)) {
      return new NextResponse('Rate limit exceeded', { 
        status: 429,
        headers: {
          'Retry-After': '60',
          ...getSecurityHeaders()
        }
      });
    }
  }
  
  // Get tokens from cookies
  const accessToken = request.cookies.get('accessToken')?.value;
  const refreshToken = request.cookies.get('refreshToken')?.value;
  
  // Parse user info from token
  let userRole: string | null = null;
  let isTokenValid = false;
  
  if (accessToken) {
    try {
      const payload = parseJWT(accessToken);
      if (payload && !isTokenExpired(accessToken)) {
        userRole = payload.role;
        isTokenValid = true;
      }
    } catch (error) {
      console.error('Failed to parse access token:', error);
    }
  }
  
  // Create response
  let response: NextResponse;
  
  // Handle public routes
  if (isPublicRoute(pathname)) {
    // Redirect authenticated users away from auth pages
    if (isTokenValid && pathname.startsWith('/auth/')) {
      response = NextResponse.redirect(new URL('/dashboard', request.url));
    } else {
      response = NextResponse.next();
    }
  }
  // Handle protected routes
  else if (isProtectedRoute(pathname)) {
    // No valid token - redirect to login
    if (!isTokenValid) {
      const loginUrl = new URL('/auth/login', request.url);
      loginUrl.searchParams.set('returnUrl', pathname);
      response = NextResponse.redirect(loginUrl);
    }
    // Check admin access
    else if (isAdminRoute(pathname)) {
      if (userRole !== 'admin' && userRole !== 'superadmin') {
        response = NextResponse.redirect(new URL('/dashboard', request.url));
      } else {
        response = NextResponse.next();
      }
    }
    // Valid token and authorized
    else {
      response = NextResponse.next();
    }
  }
  // Default case
  else {
    response = NextResponse.next();
  }
  
  // Apply security headers to all responses
  const securityHeaders = getSecurityHeaders();
  const performanceHeaders = getPerformanceHeaders();
  
  Object.entries(securityHeaders).forEach(([key, value]) => {
    response.headers.set(key, value);
  });
  
  Object.entries(performanceHeaders).forEach(([key, value]) => {
    response.headers.set(key, value);
  });
  
  // Add performance timing
  const duration = Date.now() - startTime;
  response.headers.set('Server-Timing', `middleware;dur=${duration}`);
  
  // Add security context headers for debugging (development only)
  if (process.env.NODE_ENV === 'development') {
    response.headers.set('X-Auth-Status', isTokenValid ? 'valid' : 'invalid');
    response.headers.set('X-User-Role', userRole || 'none');
    response.headers.set('X-Route-Type', isProtectedRoute(pathname) ? 'protected' : 'public');
  }
  
  return response;
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - api (API routes - handled separately)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public files (images, etc.)
     */
    '/((?!api|_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}; 