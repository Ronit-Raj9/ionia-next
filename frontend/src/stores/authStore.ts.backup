import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';
import { persist } from 'zustand/middleware';
import Cookies from 'js-cookie';
import { API } from '@/lib/api';

interface User {
  id: string;
  fullName: string;
  email: string;
  username: string;
  role: 'user' | 'admin' | 'superadmin';
  avatar?: string;
}

interface AuthState {
  // State
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
  tokenExpiresAt: number | null;
  refreshTokenExpiresAt: number | null;
  isRefreshing: boolean;
  lastActivity: number;
  
  // Actions
  setUser: (user: User | null) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  setTokens: (accessToken: string, refreshToken?: string) => void;
  clearTokens: () => void;
  logout: () => void;
  forceLogout: () => void;
  checkTokenExpiration: () => boolean;
  isTokenExpired: () => boolean;
  hasRole: (requiredRole: 'user' | 'admin' | 'superadmin') => boolean;
  hasAnyRole: (roles: string[]) => boolean;
  refreshToken: () => Promise<boolean>;
  updateActivity: () => void;
  
  // Tab synchronization
  syncState: (data: Partial<AuthState>) => void;
}

// Role hierarchy for permission checking
const ROLE_HIERARCHY = {
  user: 0,
  admin: 1,
  superadmin: 2,
};

// JWT helper functions
const parseJWT = (token: string) => {
  try {
    const base64Url = token.split('.')[1];
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    const jsonPayload = decodeURIComponent(
      atob(base64)
        .split('')
        .map((c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
        .join('')
    );
    return JSON.parse(jsonPayload);
  } catch (error) {
    console.error('Invalid JWT token:', error);
    return null;
  }
};

const isTokenExpired = (token: string): boolean => {
  const payload = parseJWT(token);
  if (!payload?.exp) return true;
  
  // Add 30-second buffer for network latency
  return Date.now() >= (payload.exp * 1000) - 30000;
};

// Secure cookie configuration
const COOKIE_OPTIONS = {
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'strict' as const,
  path: '/',
  expires: 7, // 7 days for refresh token
};

// Storage keys for tab synchronization
const AUTH_SYNC_KEY = 'auth_sync';
const LOGOUT_SYNC_KEY = 'logout_sync';

export const useAuthStore = create<AuthState>()(
  persist(
    immer((set, get) => ({
      // Initial state
      user: null,
      isAuthenticated: false,
      isLoading: false,
      error: null,
      tokenExpiresAt: null,
      refreshTokenExpiresAt: null,
      isRefreshing: false,
      lastActivity: Date.now(),

      // Actions
      setUser: (user) =>
        set((state) => {
          state.user = user;
          state.isAuthenticated = !!user;
          state.error = null;
          state.lastActivity = Date.now();
          
          // Sync across tabs
          if (typeof window !== 'undefined') {
            localStorage.setItem(AUTH_SYNC_KEY, JSON.stringify({
              user,
              isAuthenticated: !!user,
              timestamp: Date.now()
            }));
          }
        }),

      setLoading: (loading) =>
        set((state) => {
          state.isLoading = loading;
        }),

      setError: (error) =>
        set((state) => {
          state.error = error;
          if (error) {
            state.isLoading = false;
          }
        }),

      setTokens: (accessToken, refreshToken) =>
        set((state) => {
          // Parse token expiration
          const accessPayload = parseJWT(accessToken);
          if (accessPayload?.exp) {
            state.tokenExpiresAt = accessPayload.exp * 1000;
          }

          // Store access token in memory only (more secure)
          if (typeof window !== 'undefined') {
            (window as any).__accessToken = accessToken;
          }

          // Store refresh token in secure HTTP-only cookie via API
          if (refreshToken) {
            const refreshPayload = parseJWT(refreshToken);
            if (refreshPayload?.exp) {
              state.refreshTokenExpiresAt = refreshPayload.exp * 1000;
            }
            
            // Store refresh token in secure cookie
            Cookies.set('refreshToken', refreshToken, {
              ...COOKIE_OPTIONS,
              expires: 7,
            });
          }

          state.error = null;
          state.lastActivity = Date.now();
        }),

      clearTokens: () =>
        set((state) => {
          state.tokenExpiresAt = null;
          state.refreshTokenExpiresAt = null;
          
          // Clear access token from memory
          if (typeof window !== 'undefined') {
            delete (window as any).__accessToken;
          }
          
          // Clear refresh token cookie
          Cookies.remove('refreshToken');
          
          state.error = null;
        }),

      logout: () =>
        set((state) => {
          state.user = null;
          state.isAuthenticated = false;
          state.tokenExpiresAt = null;
          state.refreshTokenExpiresAt = null;
          state.error = null;
          state.isRefreshing = false;
          
          // Clear all tokens
          if (typeof window !== 'undefined') {
            delete (window as any).__accessToken;
          }
          Cookies.remove('refreshToken');
          
          // Sync logout across tabs
          if (typeof window !== 'undefined') {
            localStorage.setItem(LOGOUT_SYNC_KEY, Date.now().toString());
            localStorage.removeItem(AUTH_SYNC_KEY);
          }
        }),

      forceLogout: () => {
        const { logout } = get();
        logout();
        
        // Force redirect to login
        if (typeof window !== 'undefined') {
          window.location.href = '/auth/login';
        }
      },

      checkTokenExpiration: () => {
        const state = get();
        if (!state.tokenExpiresAt) return false;
        
        // Check if token expires in the next 5 minutes
        return Date.now() >= (state.tokenExpiresAt - 300000);
      },

      isTokenExpired: () => {
        const state = get();
        if (!state.tokenExpiresAt) return true;
        return Date.now() >= state.tokenExpiresAt;
      },

      hasRole: (requiredRole) => {
        const state = get();
        if (!state.user?.role) return false;
        
        return ROLE_HIERARCHY[state.user.role] >= ROLE_HIERARCHY[requiredRole];
      },

      hasAnyRole: (roles) => {
        const state = get();
        if (!state.user?.role) return false;
        
        return roles.includes(state.user.role);
      },

      refreshToken: async () => {
        const state = get();
        
        // Prevent multiple simultaneous refresh attempts
        if (state.isRefreshing) {
          return false;
        }

        set((draft) => {
          draft.isRefreshing = true;
          draft.error = null;
        });

        try {
          const refreshToken = getRefreshToken();
          if (!refreshToken) {
            throw new Error('No refresh token available');
          }

          const response = await API.auth.refreshToken();
          
          if (response.data?.accessToken) {
            set((draft) => {
              draft.isRefreshing = false;
            });
            
            // Update tokens
            get().setTokens(response.data.accessToken, response.data.refreshToken);
            return true;
          } else {
            throw new Error('Invalid refresh response');
          }
        } catch (error) {
          console.error('Token refresh failed:', error);
          
          set((draft) => {
            draft.isRefreshing = false;
            draft.error = 'Session expired. Please log in again.';
          });
          
          // Force logout on refresh failure
          get().forceLogout();
          return false;
        }
      },

      updateActivity: () =>
        set((state) => {
          state.lastActivity = Date.now();
        }),

      syncState: (data) =>
        set((state) => {
          if (data.user !== undefined) state.user = data.user;
          if (data.isAuthenticated !== undefined) state.isAuthenticated = data.isAuthenticated;
        }),
    })),
    {
      name: 'auth-storage',
      partialize: (state) => ({
        user: state.user,
        isAuthenticated: state.isAuthenticated,
        lastActivity: state.lastActivity,
        // Don't persist tokens in localStorage for security
      }),
    }
  )
);

// Helper to get access token securely
export const getAccessToken = (): string | null => {
  if (typeof window === 'undefined') return null;
  return (window as any).__accessToken || null;
};

// Helper to get refresh token from cookie
export const getRefreshToken = (): string | null => {
  return Cookies.get('refreshToken') || null;
};

// Auto-refresh and monitoring intervals
let tokenCheckInterval: NodeJS.Timeout;
let activityCheckInterval: NodeJS.Timeout;

export const startTokenMonitoring = () => {
  if (typeof window === 'undefined') return;
  
  // Clear existing intervals
  if (tokenCheckInterval) clearInterval(tokenCheckInterval);
  if (activityCheckInterval) clearInterval(activityCheckInterval);
  
  // Check for token refresh need every 30 seconds
  tokenCheckInterval = setInterval(async () => {
    const { isAuthenticated, checkTokenExpiration, refreshToken, isTokenExpired } = useAuthStore.getState();
    
    if (isAuthenticated) {
      if (isTokenExpired()) {
        console.log('Token expired, attempting refresh...');
        const refreshed = await refreshToken();
        if (!refreshed) {
          console.log('Refresh failed, logging out user');
        }
      } else if (checkTokenExpiration()) {
        console.log('Token expiring soon, refreshing...');
        await refreshToken();
      }
    }
  }, 30000); // Check every 30 seconds

  // Check for user activity and session timeout
  activityCheckInterval = setInterval(() => {
    const { isAuthenticated, lastActivity, forceLogout } = useAuthStore.getState();
    
    if (isAuthenticated) {
      const inactiveTime = Date.now() - lastActivity;
      // Auto-logout after 24 hours of inactivity
      if (inactiveTime > 24 * 60 * 60 * 1000) {
        console.log('Session timeout due to inactivity');
        forceLogout();
      }
    }
  }, 60000); // Check every minute
};

export const stopTokenMonitoring = () => {
  if (tokenCheckInterval) clearInterval(tokenCheckInterval);
  if (activityCheckInterval) clearInterval(activityCheckInterval);
};

// Tab synchronization setup
export const startTabSynchronization = () => {
  if (typeof window === 'undefined') return;

  const handleStorageChange = (e: StorageEvent) => {
    const { syncState, forceLogout } = useAuthStore.getState();

    if (e.key === AUTH_SYNC_KEY && e.newValue) {
      try {
        const data = JSON.parse(e.newValue);
        syncState({
          user: data.user,
          isAuthenticated: data.isAuthenticated,
        });
      } catch (error) {
        console.error('Failed to sync auth state:', error);
      }
    }

    if (e.key === LOGOUT_SYNC_KEY && e.newValue) {
      // Another tab logged out, force logout in this tab too
      forceLogout();
    }
  };

  window.addEventListener('storage', handleStorageChange);
  
  return () => {
    window.removeEventListener('storage', handleStorageChange);
  };
};

// Activity tracking for auto-logout
export const trackUserActivity = () => {
  if (typeof window === 'undefined') return;

  const { updateActivity, isAuthenticated } = useAuthStore.getState();
  
  const activities = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'];
  
  const activityHandler = () => {
    if (isAuthenticated) {
      updateActivity();
    }
  };

  activities.forEach(activity => {
    document.addEventListener(activity, activityHandler, true);
  });

  return () => {
    activities.forEach(activity => {
      document.removeEventListener(activity, activityHandler, true);
    });
  };
}; 